/**
 * File: highlight-words.js
 * Description: Highlight specific words or patterns in text content with various strategies
 * 
 * Learning objectives:
 * - Understand text processing and DOM manipulation
 * - Learn regex patterns and text matching techniques
 * - See performance considerations for text highlighting
 * 
 * Time Complexity: O(n*m) where n is text length, m is number of words
 * Space Complexity: O(n) for creating highlighted text nodes
 */

// =======================
// Approach 1: Basic Word Highlighting
// =======================

/**
 * Highlight specific words in text content
 * Wraps matched words with span elements containing highlight class
 */
function highlightWords(text, words, options = {}) {
  const {
    className = 'highlight',
    caseSensitive = false,
    wholeWords = true,
    tagName = 'mark'
  } = options;
  
  if (!text || !words) return text;\n  \n  // Normalize words to array\n  const wordsArray = Array.isArray(words) ? words : [words];\n  \n  // Build regex pattern\n  const flags = caseSensitive ? 'g' : 'gi';\n  const boundary = wholeWords ? '\\\\b' : '';\n  \n  // Escape special regex characters in words\n  const escapedWords = wordsArray.map(word => \n    word.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n  );\n  \n  const pattern = new RegExp(\n    `${boundary}(${escapedWords.join('|')})${boundary}`,\n    flags\n  );\n  \n  // Replace matches with highlighted version\n  return text.replace(pattern, `<${tagName} class=\"${className}\">$1</${tagName}>`);\n}\n\n// =======================\n// Approach 2: DOM-Based Highlighting\n// =======================\n\n/**\n * Highlight words in DOM elements while preserving existing structure\n * Safely traverses text nodes without breaking HTML\n */\nfunction highlightWordsInDOM(element, words, options = {}) {\n  const {\n    className = 'highlight',\n    caseSensitive = false,\n    wholeWords = true,\n    skipTags = ['SCRIPT', 'STYLE', 'INPUT', 'TEXTAREA']\n  } = options;\n  \n  if (!element || !words) return;\n  \n  const wordsArray = Array.isArray(words) ? words : [words];\n  const flags = caseSensitive ? 'g' : 'gi';\n  const boundary = wholeWords ? '\\\\b' : '';\n  \n  // Build regex pattern\n  const escapedWords = wordsArray.map(word => \n    word.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n  );\n  const pattern = new RegExp(\n    `${boundary}(${escapedWords.join('|')})${boundary}`,\n    flags\n  );\n  \n  // Find all text nodes\n  const walker = document.createTreeWalker(\n    element,\n    NodeFilter.SHOW_TEXT,\n    {\n      acceptNode: (node) => {\n        // Skip nodes inside excluded tags\n        const parent = node.parentNode;\n        return skipTags.includes(parent.tagName) \n          ? NodeFilter.FILTER_REJECT \n          : NodeFilter.FILTER_ACCEPT;\n      }\n    }\n  );\n  \n  const textNodes = [];\n  let node;\n  \n  while (node = walker.nextNode()) {\n    if (node.textContent.trim()) {\n      textNodes.push(node);\n    }\n  }\n  \n  // Process text nodes in reverse order to avoid position shifts\n  textNodes.reverse().forEach(textNode => {\n    const text = textNode.textContent;\n    \n    if (pattern.test(text)) {\n      // Create highlighted HTML\n      const highlightedHTML = text.replace(pattern, \n        `<mark class=\"${className}\">$1</mark>`\n      );\n      \n      // Replace text node with highlighted content\n      const tempDiv = document.createElement('div');\n      tempDiv.innerHTML = highlightedHTML;\n      \n      // Replace text node with new nodes\n      const fragment = document.createDocumentFragment();\n      while (tempDiv.firstChild) {\n        fragment.appendChild(tempDiv.firstChild);\n      }\n      \n      textNode.parentNode.replaceChild(fragment, textNode);\n    }\n  });\n}\n\n// =======================\n// Approach 3: Advanced Pattern Highlighting\n// =======================\n\n/**\n * Advanced highlighting with multiple patterns and custom styling\n * Supports regex patterns, custom classes, and priority-based highlighting\n */\nclass TextHighlighter {\n  constructor(options = {}) {\n    this.patterns = new Map();\n    this.defaultOptions = {\n      className: 'highlight',\n      caseSensitive: false,\n      wholeWords: true,\n      tagName: 'mark',\n      priority: 0\n    };\n    \n    // Merge default options\n    this.defaultOptions = { ...this.defaultOptions, ...options };\n  }\n  \n  /**\n   * Add highlighting pattern\n   */\n  addPattern(id, pattern, options = {}) {\n    const config = { ...this.defaultOptions, ...options };\n    \n    let regex;\n    if (pattern instanceof RegExp) {\n      regex = pattern;\n    } else {\n      const flags = config.caseSensitive ? 'g' : 'gi';\n      const boundary = config.wholeWords ? '\\\\b' : '';\n      const escaped = pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n      regex = new RegExp(`${boundary}(${escaped})${boundary}`, flags);\n    }\n    \n    this.patterns.set(id, {\n      regex,\n      config\n    });\n    \n    return this;\n  }\n  \n  /**\n   * Remove pattern\n   */\n  removePattern(id) {\n    this.patterns.delete(id);\n    return this;\n  }\n  \n  /**\n   * Highlight text with all patterns\n   */\n  highlight(text) {\n    if (!text) return text;\n    \n    // Sort patterns by priority (higher priority first)\n    const sortedPatterns = Array.from(this.patterns.entries())\n      .sort((a, b) => b[1].config.priority - a[1].config.priority);\n    \n    let result = text;\n    const appliedRanges = [];\n    \n    sortedPatterns.forEach(([id, { regex, config }]) => {\n      result = this.applyPattern(result, regex, config, appliedRanges);\n    });\n    \n    return result;\n  }\n  \n  /**\n   * Apply single pattern avoiding overlaps\n   */\n  applyPattern(text, regex, config, appliedRanges) {\n    const matches = [];\n    let match;\n    \n    // Find all matches\n    while ((match = regex.exec(text)) !== null) {\n      const start = match.index;\n      const end = start + match[0].length;\n      \n      // Check for overlaps with existing highlights\n      const hasOverlap = appliedRanges.some(range => \n        (start >= range.start && start < range.end) ||\n        (end > range.start && end <= range.end) ||\n        (start <= range.start && end >= range.end)\n      );\n      \n      if (!hasOverlap) {\n        matches.push({ match, start, end });\n        appliedRanges.push({ start, end });\n      }\n    }\n    \n    // Apply highlights in reverse order to maintain positions\n    matches.reverse().forEach(({ match, start, end }) => {\n      const highlighted = `<${config.tagName} class=\"${config.className}\" data-pattern=\"${match[1]}\">${match[1]}</${config.tagName}>`;\n      text = text.substring(0, start) + highlighted + text.substring(end);\n    });\n    \n    return text;\n  }\n  \n  /**\n   * Highlight DOM element\n   */\n  highlightDOM(element) {\n    const originalHTML = element.innerHTML;\n    const highlightedHTML = this.highlight(element.textContent);\n    \n    // Only update if there are changes\n    if (highlightedHTML !== element.textContent) {\n      element.innerHTML = highlightedHTML;\n    }\n  }\n  \n  /**\n   * Remove all highlights from element\n   */\n  removeHighlights(element, className = null) {\n    const selector = className ? `mark.${className}` : 'mark';\n    const highlights = element.querySelectorAll(selector);\n    \n    highlights.forEach(highlight => {\n      const parent = highlight.parentNode;\n      parent.replaceChild(\n        document.createTextNode(highlight.textContent), \n        highlight\n      );\n      parent.normalize(); // Merge adjacent text nodes\n    });\n  }\n  \n  /**\n   * Get highlighting statistics\n   */\n  getStats(text) {\n    const stats = {\n      totalMatches: 0,\n      patternStats: new Map()\n    };\n    \n    this.patterns.forEach((pattern, id) => {\n      const matches = (text.match(pattern.regex) || []).length;\n      stats.patternStats.set(id, matches);\n      stats.totalMatches += matches;\n    });\n    \n    return stats;\n  }\n}\n\n// =======================\n// Approach 4: Search and Highlight\n// =======================\n\n/**\n * Interactive search and highlight functionality\n * Supports incremental search with live highlighting\n */\nfunction createSearchHighlighter(container, options = {}) {\n  const {\n    searchInput,\n    highlightClass = 'search-highlight',\n    currentClass = 'current-highlight',\n    minLength = 2,\n    debounceMs = 300\n  } = options;\n  \n  let currentHighlights = [];\n  let currentIndex = -1;\n  let debounceTimer = null;\n  \n  const highlighter = new TextHighlighter({\n    className: highlightClass,\n    caseSensitive: false,\n    wholeWords: false\n  });\n  \n  function performSearch(query) {\n    // Clear previous highlights\n    clearHighlights();\n    \n    if (query.length < minLength) return;\n    \n    // Add search pattern\n    highlighter.addPattern('search', query, {\n      className: highlightClass\n    });\n    \n    // Highlight in container\n    highlighter.highlightDOM(container);\n    \n    // Collect all highlights\n    currentHighlights = Array.from(\n      container.querySelectorAll(`.${highlightClass}`)\n    );\n    \n    // Highlight first match as current\n    if (currentHighlights.length > 0) {\n      setCurrentHighlight(0);\n    }\n    \n    return currentHighlights.length;\n  }\n  \n  function clearHighlights() {\n    highlighter.removeHighlights(container, highlightClass);\n    currentHighlights = [];\n    currentIndex = -1;\n  }\n  \n  function setCurrentHighlight(index) {\n    // Remove current class from all highlights\n    currentHighlights.forEach(highlight => {\n      highlight.classList.remove(currentClass);\n    });\n    \n    if (index >= 0 && index < currentHighlights.length) {\n      currentIndex = index;\n      const current = currentHighlights[index];\n      current.classList.add(currentClass);\n      current.scrollIntoView({ behavior: 'smooth', block: 'center' });\n    }\n  }\n  \n  function navigateHighlights(direction) {\n    if (currentHighlights.length === 0) return;\n    \n    let nextIndex;\n    if (direction === 'next') {\n      nextIndex = (currentIndex + 1) % currentHighlights.length;\n    } else {\n      nextIndex = currentIndex - 1;\n      if (nextIndex < 0) nextIndex = currentHighlights.length - 1;\n    }\n    \n    setCurrentHighlight(nextIndex);\n  }\n  \n  // Set up search input handler\n  if (searchInput) {\n    searchInput.addEventListener('input', (e) => {\n      const query = e.target.value;\n      \n      clearTimeout(debounceTimer);\n      debounceTimer = setTimeout(() => {\n        performSearch(query);\n      }, debounceMs);\n    });\n    \n    // Handle keyboard navigation\n    searchInput.addEventListener('keydown', (e) => {\n      if (e.key === 'Enter') {\n        e.preventDefault();\n        navigateHighlights(e.shiftKey ? 'prev' : 'next');\n      }\n    });\n  }\n  \n  return {\n    search: performSearch,\n    clear: clearHighlights,\n    next: () => navigateHighlights('next'),\n    prev: () => navigateHighlights('prev'),\n    getCount: () => currentHighlights.length,\n    getCurrentIndex: () => currentIndex\n  };\n}\n\n// =======================\n// Utility Functions\n// =======================\n\n/**\n * Extract highlighted text from element\n */\nfunction extractHighlights(element, className = 'highlight') {\n  const highlights = element.querySelectorAll(`.${className}`);\n  return Array.from(highlights).map(highlight => ({\n    text: highlight.textContent,\n    element: highlight,\n    position: getTextPosition(highlight)\n  }));\n}\n\n/**\n * Get text position of element within container\n */\nfunction getTextPosition(element) {\n  const container = element.closest('[data-container]') || document.body;\n  const walker = document.createTreeWalker(\n    container,\n    NodeFilter.SHOW_TEXT,\n    null,\n    false\n  );\n  \n  let position = 0;\n  let node;\n  \n  while (node = walker.nextNode()) {\n    if (element.contains(node)) {\n      break;\n    }\n    position += node.textContent.length;\n  }\n  \n  return position;\n}\n\n// Export for use in other modules\nmodule.exports = {\n  highlightWords,\n  highlightWordsInDOM,\n  TextHighlighter,\n  createSearchHighlighter,\n  extractHighlights,\n  getTextPosition\n};